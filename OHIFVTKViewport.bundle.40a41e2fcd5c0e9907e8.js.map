{"version":3,"sources":["webpack:////home/fontenele/Documents/Viewers/extensions/vtk/src/VTKViewport.js","webpack:////home/fontenele/Documents/Viewers/extensions/vtk/src/ConnectedVTKViewport.js","webpack:////home/fontenele/Documents/Viewers/extensions/vtk/src/LoadingIndicator.js","webpack:////home/fontenele/Documents/Viewers/extensions/vtk/src/handleSegmentationStorage.js","webpack:////home/fontenele/Documents/Viewers/extensions/vtk/src/OHIFVTKViewport.js"],"names":["VTKViewport","props","setViewportActiveHandler","useCallback","setViewportActive","viewportIndex","activeViewportIndex","useEffect","handleScrollEvent","evt","onScroll","uid","detail","window","addEventListener","removeEventListener","className","style","width","height","position","onClick","propTypes","PropTypes","func","isRequired","number","defaultProps","OHIF","redux","actions","setViewportSpecificData","ConnectedVTKViewport","connect","state","ownProps","dataFromStore","extensions","vtk","isActive","viewports","pluginDetails","layout","enableStackPrefetch","dispatch","data","propsFromState","propsFromDispatch","afterCreation","onCreated","api","LoadingIndicator","percComplete","this","percentComplete","Fragment","error","message","t","PureComponent","object","withTranslation","StackManager","utils","getDisplaySet","studies","studyInstanceUid","displaySetInstanceUid","find","study","displaySets","set","getDisplaySetsBySeries","seriesInstanceUid","filter","retrieveDicomData","studyInstanceUID","seriesInstanceUID","sopInstanceUID","wadoRoot","config","url","headers","DICOMWeb","getAuthorizationHeader","options","DICOMwebClient","retrieveInstance","displaySet","images","getData","StudyInstanceUID","getStudyInstanceUID","SeriesInstanceUID","getSeriesInstanceUID","SOPInstanceUID","getSOPInstanceUID","arrayBuffer","dicomData","dcmjs","DicomMessage","readFile","dataset","DicomMetaDictionary","naturalizeDataset","dict","VTKjs","Segmentation","generateSegments","_meta","namifyDataset","meta","ReferencedSeriesSequence","length","console","warn","referenceDisplaySet","map","image","getImageId","results","Error","cachedStack","findOrCreateStack","Object","assign","currentImageIdIndex","referenceDataObject","labelmapDataObject","handleSegmentationStorage","metadataProvider","cornerstone","MetadataProvider","metaData","addProvider","provider","bind","setMetadataProvider","SOP_CLASSES","SEGMENTATION_STORAGE","volumeCache","OHIFVTKViewport","volumes","paintFilterLabelMapImageData","paintFilterBackgroundImageData","sopClassUid","sopInstanceUid","frameIndex","stack","getCornerstoneStack","getImageData","imageIds","log","clearStacks","storedStack","undefined","index","findIndex","imageId","sopCommonModule","get","imageDataObject","vtkImageData","imageMetaData0","center","modality","isNaN","lower","upper","_getRangeFromWindowLevels","windowWidth","windowCenter","volumeActor","vtkVolume","newInstance","volumeMapper","vtkVolumeMapper","setMapper","setInputData","getProperty","getRGBTransferFunction","setRange","spacing","getSpacing","sampleDistance","setSampleDistance","setMaximumSamplesPerRay","viewportData","sopClassUids","getViewportData","getOrCreateVolume","setState","loadProgressively","setTimeout","setStateFromProps","prevProps","prevDisplaySet","loadImageData","isLoading","insertPixelDataPromises","numberOfFrames","forEach","promise","then","numberProcessed","Math","floor","Promise","all","isLoaded","childrenWithProps","children","child","React","cloneElement","key","Component","shape","array","string","arrayOf","node"],"mappings":"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","file":"OHIFVTKViewport.bundle.40a41e2fcd5c0e9907e8.js","sourcesContent":["import React, { useEffect, useCallback } from 'react';\nimport { View2D } from 'react-vtkjs-viewport';\nimport PropTypes from 'prop-types';\n\nimport './VTKViewport.css';\n\nconst VTKViewport = props => {\n  const style = { width: '100%', height: '100%', position: 'relative' };\n\n  const setViewportActiveHandler = useCallback(() => {\n    const { setViewportActive, viewportIndex, activeViewportIndex } = props;\n\n    if (viewportIndex !== activeViewportIndex) {\n      // set in Connected\n      setViewportActive();\n    }\n  });\n\n  useEffect(() => {\n    const handleScrollEvent = evt => {\n      const vtkViewportApiReference = props.onScroll(props.viewportIndex) || {};\n      const viewportUid = vtkViewportApiReference.uid;\n      const viewportWasScrolled = viewportUid === evt.detail.uid;\n\n      if (viewportWasScrolled) {\n        setViewportActiveHandler();\n      }\n    };\n\n    window.addEventListener('vtkscrollevent', handleScrollEvent);\n    return () =>\n      window.removeEventListener('vtkscrollevent', handleScrollEvent);\n  }, [props, props.onScroll, props.viewportIndex, setViewportActiveHandler]);\n\n  return (\n    <div\n      className=\"vtk-viewport-handler\"\n      style={style}\n      onClick={setViewportActiveHandler}\n    >\n      <View2D {...props} />\n    </div>\n  );\n};\n\nVTKViewport.propTypes = {\n  setViewportActive: PropTypes.func.isRequired,\n  viewportIndex: PropTypes.number.isRequired,\n  activeViewportIndex: PropTypes.number.isRequired,\n  /* Receives viewportIndex */\n  onScroll: PropTypes.func,\n};\n\nVTKViewport.defaultProps = {\n  onScroll: () => {},\n};\n\nexport default VTKViewport;\n","import OHIF from '@ohif/core';\nimport { connect } from 'react-redux';\nimport VTKViewport from './VTKViewport';\n\nconst { setViewportActive, setViewportSpecificData } = OHIF.redux.actions;\n\nconst mapStateToProps = (state, ownProps) => {\n  let dataFromStore;\n\n  if (state.extensions && state.extensions.vtk) {\n    dataFromStore = state.extensions.vtk;\n  }\n\n  // If this is the active viewport, enable prefetching.\n  const { viewportIndex } = ownProps;\n  const isActive = viewportIndex === state.viewports.activeViewportIndex;\n  const viewportLayout = state.viewports.layout.viewports[viewportIndex];\n  const pluginDetails = viewportLayout.vtk || {};\n\n  return {\n    activeViewportIndex: state.viewports.activeViewportIndex,\n    layout: state.viewports.layout,\n    isActive,\n    ...pluginDetails,\n    // Hopefully this doesn't break anything under the hood for this one\n    // activeTool: activeButton && activeButton.command,\n    ...dataFromStore,\n    enableStackPrefetch: isActive,\n  };\n};\n\nconst mapDispatchToProps = (dispatch, ownProps) => {\n  const { viewportIndex } = ownProps;\n\n  return {\n    setViewportActive: () => {\n      dispatch(setViewportActive(viewportIndex));\n    },\n\n    setViewportSpecificData: data => {\n      dispatch(setViewportSpecificData(viewportIndex, data));\n    },\n  };\n};\n\nconst mergeProps = (propsFromState, propsFromDispatch, ownProps) => {\n  const { afterCreation } = propsFromState;\n\n  const props = {\n    ...propsFromState,\n    ...propsFromDispatch,\n    ...ownProps,\n    /**\n     * Our component sets up the underlying dom element on \"componentDidMount\"\n     * for use with VTK.\n     *\n     * The onCreated prop passes back an Object containing many of the internal\n     * components of the VTK scene. We can grab a reference to these here, to\n     * make playing with VTK's native methods easier.\n     *\n     * A similar approach is taken with the Cornerstone extension.\n     */\n    onCreated: api => {\n      // Store the API details for later\n      //setViewportSpecificData({ vtkApi: api });\n\n      if (afterCreation && typeof afterCreation === 'function') {\n        afterCreation(api);\n      }\n    },\n  };\n  return props;\n};\n\nconst ConnectedVTKViewport = connect(\n  mapStateToProps,\n  mapDispatchToProps,\n  mergeProps\n)(VTKViewport);\n\nexport default ConnectedVTKViewport;\n","import './LoadingIndicator.css';\n\nimport React, { PureComponent } from 'react';\nimport { withTranslation } from 'react-i18next';\nimport PropTypes from 'prop-types';\n\nclass LoadingIndicator extends PureComponent {\n  static propTypes = {\n    percentComplete: PropTypes.number.isRequired,\n    error: PropTypes.object,\n  };\n\n  static defaultProps = {\n    percentComplete: 0,\n    error: null,\n  };\n\n  render() {\n    let percComplete;\n    if (this.props.percentComplete && this.props.percentComplete !== 100) {\n      percComplete = `${this.props.percentComplete}%`;\n    }\n\n    return (\n      <React.Fragment>\n        {this.props.error ? (\n          <div className=\"imageViewerErrorLoadingIndicator loadingIndicator\">\n            <div className=\"indicatorContents\">\n              <h4>Error Loading Image</h4>\n              <p className=\"description\">An error has occurred.</p>\n              <p className=\"details\">{this.props.error.message}</p>\n            </div>\n          </div>\n        ) : (\n            <div className=\"imageViewerLoadingIndicator loadingIndicator\">\n              <div className=\"indicatorContents\">\n                <p>\n                  {this.props.t('Reformatando')}...\n                <i className=\"fa fa-spin fa-circle-o-notch fa-fw\" />\n                  {percComplete}\n                </p>\n              </div>\n            </div>\n          )}\n      </React.Fragment>\n    );\n  }\n}\n\nexport default withTranslation('Common')(LoadingIndicator);\n","import * as dcmjs from \"dcmjs\";\n\nimport OHIF from \"@ohif/core\";\nimport { api } from \"dicomweb-client\";\n\nconst { StackManager } = OHIF.utils;\n\nfunction getDisplaySet(studies, studyInstanceUid, displaySetInstanceUid) {\n  const study = studies.find(\n    study => study.studyInstanceUid === studyInstanceUid\n  );\n\n  const displaySet = study.displaySets.find(set => {\n    return set.displaySetInstanceUid === displaySetInstanceUid;\n  });\n\n  return displaySet;\n}\n\nfunction getDisplaySetsBySeries(studies, studyInstanceUid, seriesInstanceUid) {\n  const study = studies.find(\n    study => study.studyInstanceUid === studyInstanceUid\n  );\n\n  return study.displaySets.filter(set => {\n    return set.seriesInstanceUid === seriesInstanceUid;\n  });\n}\n\nfunction getCornerstoneStack(studies, studyInstanceUid, displaySetInstanceUid) {\n  const study = studies.find(\n    study => study.studyInstanceUid === studyInstanceUid\n  );\n\n  // Create shortcut to displaySet\n  const displaySet = getDisplaySet(\n    studies,\n    studyInstanceUid,\n    displaySetInstanceUid\n  );\n\n  // Get stack from Stack Manager\n  const stack = StackManager.findOrCreateStack(study, displaySet);\n\n  // Clone the stack here so we don't mutate it later\n  const stackClone = Object.assign({}, stack);\n  stackClone.currentImageIdIndex = 0;\n\n  return stackClone;\n}\n\nfunction retrieveDicomData(\n  studyInstanceUID,\n  seriesInstanceUID,\n  sopInstanceUID,\n  wadoRoot\n) {\n  const config = {\n    url: wadoRoot,\n    headers: DICOMWeb.getAuthorizationHeader()\n  };\n\n  const dicomWeb = new api.DICOMwebClient(config);\n  const options = {\n    studyInstanceUID,\n    seriesInstanceUID,\n    sopInstanceUID\n  };\n\n  return dicomWeb.retrieveInstance(options);\n}\n\nasync function handleSegmentationStorage(\n  studies,\n  studyInstanceUid,\n  displaySetInstanceUid\n) {\n  const study = studies.find(\n    study => study.studyInstanceUid === studyInstanceUid\n  );\n  const displaySet = getDisplaySet(\n    studies,\n    studyInstanceUid,\n    displaySetInstanceUid\n  );\n\n  // TODO: This is terrible but we need to use WADO-RS or we can't retrieve the SEG\n  // from google cloud\n  const wadoRoot = displaySet.images[0].getData().wadoRoot;\n\n  const StudyInstanceUID = displaySet.images[0].getStudyInstanceUID();\n  const SeriesInstanceUID = displaySet.images[0].getSeriesInstanceUID();\n  const SOPInstanceUID = displaySet.images[0].getSOPInstanceUID();\n\n  const arrayBuffer = await retrieveDicomData(\n    StudyInstanceUID,\n    SeriesInstanceUID,\n    SOPInstanceUID,\n    wadoRoot\n  );\n\n  const dicomData = dcmjs.data.DicomMessage.readFile(arrayBuffer);\n  const dataset = dcmjs.data.DicomMetaDictionary.naturalizeDataset(\n    dicomData.dict\n  );\n\n  const segments = dcmjs.adapters.VTKjs.Segmentation.generateSegments(dataset);\n\n  dataset._meta = dcmjs.data.DicomMetaDictionary.namifyDataset(dicomData.meta);\n\n  const seriesInstanceUid = dataset.ReferencedSeriesSequence.SeriesInstanceUID;\n  const displaySets = getDisplaySetsBySeries(\n    studies,\n    studyInstanceUid,\n    seriesInstanceUid\n  );\n\n  if (displaySets.length > 1) {\n    console.warn(\n      \"More than one display set with the same seriesInstanceUid. This is not supported yet...\"\n    );\n  }\n\n  const referenceDisplaySet = displaySets[0];\n  const imageIds = referenceDisplaySet.images.map(image => image.getImageId());\n\n  if (!results) {\n    throw new Error(\"Fractional segmentations are not supported\");\n  }\n\n  const cachedStack = StackManager.findOrCreateStack(\n    study,\n    referenceDisplaySet\n  );\n  const stack = Object.assign({}, cachedStack);\n  stack.currentImageIdIndex = 0;\n\n  return {\n    referenceDataObject,\n    labelmapDataObject\n  };\n\n  return {\n    studyInstanceUid,\n    displaySetInstanceUid,\n    stack\n  };\n}\n\nexport default handleSegmentationStorage;\n","import React, { Component } from 'react';\nimport { getImageData, loadImageData } from 'react-vtkjs-viewport';\n\nimport ConnectedVTKViewport from './ConnectedVTKViewport';\nimport LoadingIndicator from './LoadingIndicator.js';\nimport OHIF from '@ohif/core';\nimport PropTypes from 'prop-types';\nimport cornerstone from 'cornerstone-core';\nimport handleSegmentationStorage from './handleSegmentationStorage.js';\nimport vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';\nimport vtkImageData from 'vtk.js/Sources/Common/DataModel/ImageData';\nimport vtkVolume from 'vtk.js/Sources/Rendering/Core/Volume';\nimport vtkVolumeMapper from 'vtk.js/Sources/Rendering/Core/VolumeMapper';\n\nconst { StackManager } = OHIF.utils;\n\n// Metadata configuration\nconst metadataProvider = new OHIF.cornerstone.MetadataProvider();\n\ncornerstone.metaData.addProvider(\n  metadataProvider.provider.bind(metadataProvider)\n);\n\nStackManager.setMetadataProvider(metadataProvider);\n\nconst SOP_CLASSES = {\n  SEGMENTATION_STORAGE: '1.2.840.10008.5.1.4.1.1.66.4',\n};\n\nconst specialCaseHandlers = {};\nspecialCaseHandlers[\n  SOP_CLASSES.SEGMENTATION_STORAGE\n] = handleSegmentationStorage;\n\n// TODO: Figure out where we plan to put this long term\nconst volumeCache = {};\n\n/**\n * Create a labelmap image with the same dimensions as our background volume.\n *\n * @param backgroundImageData vtkImageData\n */\nfunction createLabelMapImageData(backgroundImageData) {\n  const labelMapData = vtkImageData.newInstance(\n    backgroundImageData.get('spacing', 'origin', 'direction')\n  );\n  labelMapData.setDimensions(backgroundImageData.getDimensions());\n  labelMapData.computeTransforms();\n\n  const values = new Uint8Array(backgroundImageData.getNumberOfPoints());\n  const dataArray = vtkDataArray.newInstance({\n    numberOfComponents: 1, // labelmap with single component\n    values,\n  });\n  labelMapData.getPointData().setScalars(dataArray);\n\n  return labelMapData;\n}\n\nclass OHIFVTKViewport extends Component {\n  state = {\n    volumes: null,\n    paintFilterLabelMapImageData: null,\n    paintFilterBackgroundImageData: null,\n  };\n\n  static propTypes = {\n    viewportData: PropTypes.shape({\n      studies: PropTypes.array,\n      displaySet: PropTypes.shape({\n        studyInstanceUid: PropTypes.string,\n        displaySetInstanceUid: PropTypes.string,\n        sopClassUids: PropTypes.arrayOf(PropTypes.string),\n        sopInstanceUid: PropTypes.string,\n        frameIndex: PropTypes.number,\n      }),\n    }),\n    viewportIndex: PropTypes.number,\n    children: PropTypes.node,\n    onScroll: PropTypes.func,\n  };\n\n  static defaultProps = {\n    onScroll: () => {},\n  };\n\n  static id = 'OHIFVTKViewport';\n\n  static init() {\n    console.log('OHIFVTKViewport init()');\n  }\n\n  static destroy() {\n    console.log('OHIFVTKViewport destroy()');\n    StackManager.clearStacks();\n  }\n\n  static getCornerstoneStack(\n    studies,\n    studyInstanceUid,\n    displaySetInstanceUid,\n    sopInstanceUid,\n    frameIndex\n  ) {\n    // Create shortcut to displaySet\n    const study = studies.find(\n      study => study.studyInstanceUid === studyInstanceUid\n    );\n\n    const displaySet = study.displaySets.find(set => {\n      return set.displaySetInstanceUid === displaySetInstanceUid;\n    });\n\n    // Get stack from Stack Manager\n    const storedStack = StackManager.findOrCreateStack(study, displaySet);\n\n    // Clone the stack here so we don't mutate it\n    const stack = Object.assign({}, storedStack);\n\n    if (frameIndex !== undefined) {\n      stack.currentImageIdIndex = frameIndex;\n    } else if (sopInstanceUid) {\n      const index = stack.imageIds.findIndex(imageId => {\n        const sopCommonModule = cornerstone.metaData.get(\n          'sopCommonModule',\n          imageId\n        );\n        if (!sopCommonModule) {\n          return;\n        }\n\n        return sopCommonModule.sopInstanceUID === sopInstanceUid;\n      });\n\n      if (index > -1) {\n        stack.currentImageIdIndex = index;\n      }\n    } else {\n      stack.currentImageIdIndex = 0;\n    }\n\n    return stack;\n  }\n\n  getViewportData = (\n    studies,\n    studyInstanceUid,\n    displaySetInstanceUid,\n    sopClassUid,\n    sopInstanceUid,\n    frameIndex\n  ) => {\n    const stack = OHIFVTKViewport.getCornerstoneStack(\n      studies,\n      studyInstanceUid,\n      displaySetInstanceUid,\n      sopClassUid,\n      sopInstanceUid,\n      frameIndex\n    );\n\n    let imageDataObject;\n    let labelmapDataObject;\n\n    switch (sopClassUid) {\n      case SOP_CLASSES.SEGMENTATION_STORAGE:\n        throw new Error('Not yet implemented');\n      /*\n        const data = handleSegmentationStorage(\n          stack.imageIds,\n          displaySetInstanceUid\n        );\n\n        imageDataObject = data.referenceDataObject;\n        labelmapDataObject = data.labelmapDataObject;\n\n        return loadImageData(imageDataObject).then(() => {\n          return {\n            data: imageDataObject.vtkImageData,\n            labelmap: labelmapDataObject,\n          };\n        });\n        */\n      default:\n        imageDataObject = getImageData(stack.imageIds, displaySetInstanceUid);\n\n        return imageDataObject;\n    }\n  };\n\n  /**\n   *\n   *\n   * @param {object} imageDataObject\n   * @param {object} imageDataObject.vtkImageData\n   * @param {object} imageDataObject.imageMetaData0\n   * @param {number} [imageDataObject.imageMetaData0.windowWidth] - The volume's initial windowWidth\n   * @param {number} [imageDataObject.imageMetaData0.windowCenter] - The volume's initial windowCenter\n   * @param {string} imageDataObject.imageMetaData0.modality - CT, MR, PT, etc\n   * @param {string} displaySetInstanceUid\n   * @returns vtkVolumeActor\n   * @memberof OHIFVTKViewport\n   */\n  getOrCreateVolume(imageDataObject, displaySetInstanceUid) {\n    if (volumeCache[displaySetInstanceUid]) {\n      return volumeCache[displaySetInstanceUid];\n    }\n\n    const { vtkImageData, imageMetaData0 } = imageDataObject;\n    const { windowWidth, windowCenter, modality } = imageMetaData0;\n\n    const { lower, upper } = _getRangeFromWindowLevels(\n      windowWidth,\n      windowCenter,\n      modality\n    );\n    const volumeActor = vtkVolume.newInstance();\n    const volumeMapper = vtkVolumeMapper.newInstance();\n\n    volumeActor.setMapper(volumeMapper);\n    volumeMapper.setInputData(vtkImageData);\n\n    volumeActor\n      .getProperty()\n      .getRGBTransferFunction(0)\n      .setRange(lower, upper);\n\n    const spacing = vtkImageData.getSpacing();\n    // Set the sample distance to half the mean length of one side. This is where the divide by 6 comes from.\n    // https://github.com/Kitware/VTK/blob/6b559c65bb90614fb02eb6d1b9e3f0fca3fe4b0b/Rendering/VolumeOpenGL2/vtkSmartVolumeMapper.cxx#L344\n    const sampleDistance = (spacing[0] + spacing[1] + spacing[2]) / 6;\n\n    volumeMapper.setSampleDistance(sampleDistance);\n\n    // Be generous to surpress warnings, as the logging really hurts performance.\n    // TODO: maybe we should auto adjust samples to 1000.\n    volumeMapper.setMaximumSamplesPerRay(4000);\n\n    volumeCache[displaySetInstanceUid] = volumeActor;\n\n    return volumeActor;\n  }\n\n  setStateFromProps() {\n    const { studies, displaySet } = this.props.viewportData;\n    const {\n      studyInstanceUid,\n      displaySetInstanceUid,\n      sopClassUids,\n      sopInstanceUid,\n      frameIndex,\n    } = displaySet;\n\n    if (sopClassUids.length > 1) {\n      console.warn(\n        'More than one SOPClassUid in the same series is not yet supported.'\n      );\n    }\n\n    const sopClassUid = sopClassUids[0];\n    const imageDataObject = this.getViewportData(\n      studies,\n      studyInstanceUid,\n      displaySetInstanceUid,\n      sopClassUid,\n      sopInstanceUid,\n      frameIndex\n    );\n\n    this.imageDataObject = imageDataObject;\n\n    // TODO: Temporarily disabling this since it is not yet\n    // being used and hurts performance significantly.\n    /*if (!labelmap) {\n      labelmap = createLabelMapImageData(data);\n    }*/\n\n    const volumeActor = this.getOrCreateVolume(\n      imageDataObject,\n      displaySetInstanceUid\n    );\n\n    this.setState({\n      paintFilterBackgroundImageData: imageDataObject.vtkImageData,\n      paintFilterLabelMapImageData: null, // TODO\n      percentComplete: 0,\n    });\n\n    this.setState(\n      {\n        paintFilterBackgroundImageData: imageDataObject.vtkImageData,\n        paintFilterLabelMapImageData: null, // TODO\n        percentComplete: 0,\n      },\n      () => {\n        this.loadProgressively(imageDataObject);\n\n        // TODO: There must be a better way to do this.\n        // We do this so that if all the data is available the react-vtkjs-viewport\n        // Will render _something_ before the volumes are set and the volume\n        // Construction that happens in react-vtkjs-viewport locks up the CPU.\n        setTimeout(() => {\n          this.setState({\n            volumes: [volumeActor],\n          });\n        }, 200);\n      }\n    );\n  }\n\n  componentDidMount() {\n    this.setStateFromProps();\n  }\n\n  componentDidUpdate(prevProps) {\n    const { studies, displaySet } = this.props.viewportData;\n    const prevDisplaySet = prevProps.viewportData.displaySet;\n\n    if (\n      displaySet.displaySetInstanceUid !==\n        prevDisplaySet.displaySetInstanceUid ||\n      displaySet.sopInstanceUid !== prevDisplaySet.sopInstanceUid ||\n      displaySet.frameIndex !== prevDisplaySet.frameIndex\n    ) {\n      this.setStateFromProps();\n    }\n  }\n\n  loadProgressively(imageDataObject) {\n    loadImageData(imageDataObject);\n\n    const { isLoading, insertPixelDataPromises } = imageDataObject;\n\n    const numberOfFrames = insertPixelDataPromises.length;\n\n    if (!isLoading) {\n      this.setState({ isLoaded: true });\n      return;\n    }\n\n    insertPixelDataPromises.forEach(promise => {\n      promise.then(numberProcessed => {\n        const percentComplete = Math.floor(\n          (numberProcessed * 100) / numberOfFrames\n        );\n\n        if (percentComplete !== this.state.percentComplete) {\n          this.setState({\n            percentComplete,\n          });\n        }\n      });\n    });\n\n    Promise.all(insertPixelDataPromises).then(() => {\n      this.setState({ isLoaded: true });\n    });\n  }\n\n  render() {\n    let childrenWithProps = null;\n\n    // TODO: Does it make more sense to use Context?\n    if (this.props.children && this.props.children.length) {\n      childrenWithProps = this.props.children.map((child, index) => {\n        return (\n          child &&\n          React.cloneElement(child, {\n            viewportIndex: this.props.viewportIndex,\n            key: index,\n          })\n        );\n      });\n    }\n\n    const style = { width: '100%', height: '100%', position: 'relative' };\n\n    return (\n      <>\n        <div style={style}>\n          {!this.state.isLoaded && (\n            <LoadingIndicator percentComplete={this.state.percentComplete} />\n          )}\n          {this.state.volumes && (\n            <ConnectedVTKViewport\n              volumes={this.state.volumes}\n              paintFilterLabelMapImageData={\n                this.state.paintFilterLabelMapImageData\n              }\n              paintFilterBackgroundImageData={\n                this.state.paintFilterBackgroundImageData\n              }\n              viewportIndex={this.props.viewportIndex}\n              onScroll={this.props.onScroll}\n            />\n          )}\n        </div>\n        )}\n        {childrenWithProps}\n      </>\n    );\n  }\n}\n\n/**\n * Takes window levels and converts them to a range (lower/upper)\n * for use with VTK RGBTransferFunction\n *\n * @private\n * @param {number} [width] - the width of our window\n * @param {number} [center] - the center of our window\n * @param {string} [modality] - 'PT', 'CT', etc.\n * @returns { lower, upper } - range\n */\nfunction _getRangeFromWindowLevels(width, center, modality = undefined) {\n  const levelsAreNotNumbers = isNaN(center) || isNaN(width);\n\n  if (levelsAreNotNumbers) {\n    return { lower: 0, upper: 512 };\n  }\n\n  // For PET just set the range to 0-5 SUV\n  if (modality === 'PT') {\n    return { lower: 0, upper: 5 };\n  }\n\n  return {\n    lower: center - width / 2.0,\n    upper: center + width / 2.0,\n  };\n}\n\nexport default OHIFVTKViewport;\n"],"sourceRoot":""}