{"version":3,"sources":["webpack:////home/fontenele/Documents/Viewers/extensions/cornerstone/src/ConnectedCornerstoneViewport.js","webpack:////home/fontenele/Documents/Viewers/extensions/cornerstone/src/handleSegmentationStorage.js","webpack:////home/fontenele/Documents/Viewers/extensions/cornerstone/src/OHIFCornerstoneViewport.js"],"names":["OHIF","redux","actions","setViewportActive","setViewportSpecificData","measurements","MeasurementHandlers","onAdded","onRemoved","onModified","MEASUREMENT_ACTION_MAP","added","removed","modified","throttle","event","ConnectedCornerstoneViewport","connect","state","ownProps","dataFromStore","extensions","cornerstone","viewportIndex","isActive","viewports","activeViewportIndex","viewportSpecificData","isPlaying","frameRate","cine","cineFrameRate","isStackPrefetchEnabled","dispatch","data","onElementEnabled","enabledElement","detail","element","setEnabledElement","plugin","onMeasurementsChanged","action","CornerstoneViewport","utils","StackManager","DicomLoaderService","getDisplaySet","studies","studyInstanceUid","displaySetInstanceUid","find","study","displaySets","set","getDisplaySetsBySeries","seriesInstanceUid","filter","parseSeg","arrayBuffer","imageIds","dcmjs","Cornerstone","Segmentation","generateToolState","metaData","displaySet","findDicomDataPromise","dicomData","DicomMessage","readFile","dataset","DicomMetaDictionary","naturalizeDataset","dict","_meta","namifyDataset","meta","ReferencedSeriesSequence","SeriesInstanceUID","length","console","warn","referenceDisplaySet","images","map","image","getImageId","results","Error","labelmapBuffer","segMetadata","segmentsOnFrame","cornerstoneTools","getModule","setters","labelmap3DByFirstImageId","cachedStack","findOrCreateStack","stack","Object","assign","currentImageIdIndex","handleSegmentationStorage","metadataProvider","MetadataProvider","addProvider","provider","bind","setMetadataProvider","SOP_CLASSES","SEGMENTATION_STORAGE","specialCaseHandlers","OHIFCornerstoneViewport","viewportData","sopClassUid","sopInstanceUid","frameIndex","specialCaseHandler","getCornerstoneStack","log","clearStacks","storedStack","index","findIndex","imageId","sopCommonModule","get","sopInstanceUID","this","props","sopClassUids","getViewportData","then","setState","setStateFromProps","prevProps","prevDisplaySet","childrenWithProps","children","child","React","cloneElement","key","imageIdIndex","customProps","Component","PropTypes","object","number","node"],"mappings":"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","file":"OHIFCornerstoneViewport.bundle.9d999b50ff43c57eb523.js","sourcesContent":["import CornerstoneViewport from 'react-cornerstone-viewport';\nimport OHIF from '@ohif/core';\nimport { connect } from 'react-redux';\nimport throttle from 'lodash.throttle';\nimport { setEnabledElement } from './state';\n\nconst { setViewportActive, setViewportSpecificData } = OHIF.redux.actions;\nconst {\n  onAdded,\n  onRemoved,\n  onModified,\n} = OHIF.measurements.MeasurementHandlers;\n\n// TODO: Transition to enums for the action names so that we can ensure they stay up to date\n// everywhere they're used.\nconst MEASUREMENT_ACTION_MAP = {\n  added: onAdded,\n  removed: onRemoved,\n  modified: throttle(event => {\n    return onModified(event);\n  }, 300),\n};\n\nconst mapStateToProps = (state, ownProps) => {\n  let dataFromStore;\n\n  // TODO: This may not be updated anymore :thinking:\n  if (state.extensions && state.extensions.cornerstone) {\n    dataFromStore = state.extensions.cornerstone;\n  }\n\n  // If this is the active viewport, enable prefetching.\n  const { viewportIndex } = ownProps; //.viewportData;\n  const isActive = viewportIndex === state.viewports.activeViewportIndex;\n  const viewportSpecificData =\n    state.viewports.viewportSpecificData[viewportIndex] || {};\n\n  // CINE\n  let isPlaying = false;\n  let frameRate = 24;\n\n  if (viewportSpecificData && viewportSpecificData.cine) {\n    const cine = viewportSpecificData.cine;\n\n    isPlaying = cine.isPlaying === true;\n    frameRate = cine.cineFrameRate || frameRate;\n  }\n\n  return {\n    // layout: state.viewports.layout,\n    isActive,\n    // TODO: Need a cleaner and more versatile way.\n    // Currently justing using escape hatch + commands\n    // activeTool: activeButton && activeButton.command,\n    ...dataFromStore,\n    isStackPrefetchEnabled: isActive,\n    isPlaying,\n    frameRate,\n    //stack: viewportSpecificData.stack,\n    // viewport: viewportSpecificData.viewport,\n  };\n};\n\nconst mapDispatchToProps = (dispatch, ownProps) => {\n  const { viewportIndex } = ownProps;\n\n  return {\n    setViewportActive: () => {\n      dispatch(setViewportActive(viewportIndex));\n    },\n\n    setViewportSpecificData: data => {\n      dispatch(setViewportSpecificData(viewportIndex, data));\n    },\n\n    /**\n     * Our component \"enables\" the underlying dom element on \"componentDidMount\"\n     * It listens for that event, and then emits the enabledElement. We can grab\n     * a reference to it here, to make playing with cornerstone's native methods\n     * easier.\n     */\n    onElementEnabled: event => {\n      const enabledElement = event.detail.element;\n      setEnabledElement(viewportIndex, enabledElement);\n      dispatch(\n        setViewportSpecificData(viewportIndex, {\n          // TODO: Hack to make sure our plugin info is available from the outset\n          plugin: 'cornerstone',\n        })\n      );\n    },\n\n    onMeasurementsChanged: (event, action) => {\n      return MEASUREMENT_ACTION_MAP[action](event);\n    },\n  };\n};\n\nconst ConnectedCornerstoneViewport = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(CornerstoneViewport);\n\nexport default ConnectedCornerstoneViewport;\n","import * as dcmjs from 'dcmjs';\n\nimport OHIF from '@ohif/core';\nimport cornerstone from 'cornerstone-core';\nimport cornerstoneTools from 'cornerstone-tools';\n\nconst { StackManager, DicomLoaderService } = OHIF.utils;\n\nfunction getDisplaySet(studies, studyInstanceUid, displaySetInstanceUid) {\n  const study = studies.find(\n    study => study.studyInstanceUid === studyInstanceUid\n  );\n\n  const displaySet = study.displaySets.find(set => {\n    return set.displaySetInstanceUid === displaySetInstanceUid;\n  });\n\n  return displaySet;\n}\n\nfunction getDisplaySetsBySeries(studies, studyInstanceUid, seriesInstanceUid) {\n  const study = studies.find(\n    study => study.studyInstanceUid === studyInstanceUid\n  );\n\n  return study.displaySets.filter(set => {\n    return set.seriesInstanceUid === seriesInstanceUid;\n  });\n}\n\nfunction parseSeg(arrayBuffer, imageIds) {\n  return dcmjs.adapters.Cornerstone.Segmentation.generateToolState(\n    imageIds,\n    arrayBuffer,\n    cornerstone.metaData\n  );\n}\n\nfunction addSegMetadataToCornerstoneToolState(\n  segMetadata,\n  toolState,\n  displaySetInstanceUid\n) {\n  cornerstoneTools.globalImageIdSpecificToolStateManager.restoreToolState(\n    toolState\n  );\n\n  const brushModule = cornerstoneTools.store.modules.brush;\n\n  for (let i = 0; i < segMetadata.length; i++) {\n    brushModule.setters.metadata(displaySetInstanceUid, i, segMetadata[i]);\n  }\n}\n\nasync function handleSegmentationStorage(\n  studies,\n  studyInstanceUid,\n  displaySetInstanceUid\n) {\n  const study = studies.find(\n    study => study.studyInstanceUid === studyInstanceUid\n  );\n  const displaySet = getDisplaySet(\n    studies,\n    studyInstanceUid,\n    displaySetInstanceUid\n  );\n\n  const arrayBuffer = await DicomLoaderService.findDicomDataPromise(\n    displaySet,\n    studies\n  );\n  const dicomData = dcmjs.data.DicomMessage.readFile(arrayBuffer);\n  const dataset = dcmjs.data.DicomMetaDictionary.naturalizeDataset(\n    dicomData.dict\n  );\n\n  dataset._meta = dcmjs.data.DicomMetaDictionary.namifyDataset(dicomData.meta);\n\n  const seriesInstanceUid = dataset.ReferencedSeriesSequence.SeriesInstanceUID;\n  const displaySets = getDisplaySetsBySeries(\n    studies,\n    studyInstanceUid,\n    seriesInstanceUid\n  );\n\n  if (displaySets.length > 1) {\n    console.warn(\n      'More than one display set with the same seriesInstanceUid. This is not supported yet...'\n    );\n  }\n\n  const referenceDisplaySet = displaySets[0];\n  const imageIds = referenceDisplaySet.images.map(image => image.getImageId());\n  const results = parseSeg(arrayBuffer, imageIds);\n\n  if (!results) {\n    throw new Error('Fractional segmentations are not supported');\n  }\n\n  const { labelmapBuffer, segMetadata, segmentsOnFrame } = results;\n  const { setters } = cornerstoneTools.getModule('segmentation');\n\n  setters.labelmap3DByFirstImageId(\n    imageIds[0],\n    labelmapBuffer,\n    0, // TODO -> Can define a color LUT based on colors in the SEG later.\n    segMetadata,\n    imageIds.length,\n    segmentsOnFrame\n  );\n\n  const cachedStack = StackManager.findOrCreateStack(\n    study,\n    referenceDisplaySet\n  );\n  const stack = Object.assign({}, cachedStack);\n\n  stack.currentImageIdIndex = 0;\n\n  return {\n    studyInstanceUid,\n    displaySetInstanceUid,\n    stack,\n  };\n}\n\nexport default handleSegmentationStorage;\n","import React, { Component } from 'react';\n\nimport ConnectedCornerstoneViewport from './ConnectedCornerstoneViewport';\nimport OHIF from '@ohif/core';\nimport PropTypes from 'prop-types';\nimport cornerstone from 'cornerstone-core';\nimport handleSegmentationStorage from './handleSegmentationStorage.js';\n\nconst { StackManager } = OHIF.utils;\n\n// Metadata configuration\nconst metadataProvider = new OHIF.cornerstone.MetadataProvider();\n\ncornerstone.metaData.addProvider(\n  metadataProvider.provider.bind(metadataProvider)\n);\n\nStackManager.setMetadataProvider(metadataProvider);\n\nconst SOP_CLASSES = {\n  SEGMENTATION_STORAGE: '1.2.840.10008.5.1.4.1.1.66.4',\n};\n\nconst specialCaseHandlers = {};\nspecialCaseHandlers[\n  SOP_CLASSES.SEGMENTATION_STORAGE\n] = handleSegmentationStorage;\n\nclass OHIFCornerstoneViewport extends Component {\n  state = {\n    viewportData: null,\n  };\n\n  static defaultProps = {\n    customProps: {},\n  };\n\n  static propTypes = {\n    studies: PropTypes.object,\n    displaySet: PropTypes.object,\n    viewportIndex: PropTypes.number,\n    children: PropTypes.node,\n    customProps: PropTypes.object,\n  };\n\n  static id = 'OHIFCornerstoneViewport';\n\n  static init() {\n    console.log('OHIFCornerstoneViewport init()');\n  }\n\n  static destroy() {\n    console.log('OHIFCornerstoneViewport destroy()');\n    StackManager.clearStacks();\n  }\n\n  /**\n   * Obtain the CornerstoneTools Stack for the specified display set.\n   *\n   * @param {Object[]} studies\n   * @param {String} studyInstanceUid\n   * @param {String} displaySetInstanceUid\n   * @param {String} [sopInstanceUid]\n   * @param {Number} [frameIndex=1]\n   * @return {Object} CornerstoneTools Stack\n   */\n  static getCornerstoneStack(\n    studies,\n    studyInstanceUid,\n    displaySetInstanceUid,\n    sopInstanceUid,\n    frameIndex = 0\n  ) {\n    if (!studies || !studies.length) {\n      throw new Error('Studies not provided.');\n    }\n\n    if (!studyInstanceUid) {\n      throw new Error('StudyInstanceUID not provided.');\n    }\n\n    if (!displaySetInstanceUid) {\n      throw new Error('StudyInstanceUID not provided.');\n    }\n\n    // Create shortcut to displaySet\n    const study = studies.find(\n      study => study.studyInstanceUid === studyInstanceUid\n    );\n\n    if (!study) {\n      throw new Error('Study not found.');\n    }\n\n    const displaySet = study.displaySets.find(set => {\n      return set.displaySetInstanceUid === displaySetInstanceUid;\n    });\n\n    if (!displaySet) {\n      throw new Error('Display Set not found.');\n    }\n\n    // Get stack from Stack Manager\n    const storedStack = StackManager.findOrCreateStack(study, displaySet);\n\n    // Clone the stack here so we don't mutate it\n    const stack = Object.assign({}, storedStack);\n    stack.currentImageIdIndex = frameIndex;\n\n    if (sopInstanceUid) {\n      const index = stack.imageIds.findIndex(imageId => {\n        const sopCommonModule = cornerstone.metaData.get(\n          'sopCommonModule',\n          imageId\n        );\n        if (!sopCommonModule) {\n          return;\n        }\n\n        return sopCommonModule.sopInstanceUID === sopInstanceUid;\n      });\n\n      if (index > -1) {\n        stack.currentImageIdIndex = index;\n      } else {\n        console.warn(\n          'SOPInstanceUID provided was not found in specified DisplaySet'\n        );\n      }\n    }\n\n    return stack;\n  }\n\n  getViewportData = async (\n    studies,\n    studyInstanceUid,\n    displaySetInstanceUid,\n    sopClassUid,\n    sopInstanceUid,\n    frameIndex\n  ) => {\n    let viewportData;\n\n    switch (sopClassUid) {\n      case SOP_CLASSES.SEGMENTATION_STORAGE:\n        const specialCaseHandler =\n          specialCaseHandlers[SOP_CLASSES.SEGMENTATION_STORAGE];\n\n        viewportData = await specialCaseHandler(\n          studies,\n          studyInstanceUid,\n          displaySetInstanceUid,\n          sopInstanceUid,\n          frameIndex\n        );\n        break;\n      default:\n        const stack = OHIFCornerstoneViewport.getCornerstoneStack(\n          studies,\n          studyInstanceUid,\n          displaySetInstanceUid,\n          sopInstanceUid,\n          frameIndex\n        );\n\n        viewportData = {\n          studyInstanceUid,\n          displaySetInstanceUid,\n          stack,\n        };\n\n        break;\n    }\n\n    return viewportData;\n  };\n\n  setStateFromProps() {\n    const { studies, displaySet } = this.props.viewportData;\n    const {\n      studyInstanceUid,\n      displaySetInstanceUid,\n      sopClassUids,\n      sopInstanceUid,\n      frameIndex,\n    } = displaySet;\n\n    if (!studyInstanceUid || !displaySetInstanceUid) {\n      return;\n    }\n\n    if (sopClassUids && sopClassUids.length > 1) {\n      console.warn(\n        'More than one SOPClassUid in the same series is not yet supported.'\n      );\n    }\n\n    const sopClassUid = sopClassUids && sopClassUids[0];\n\n    this.getViewportData(\n      studies,\n      studyInstanceUid,\n      displaySetInstanceUid,\n      sopClassUid,\n      sopInstanceUid,\n      frameIndex\n    ).then(viewportData => {\n      this.setState({\n        viewportData,\n      });\n    });\n  }\n\n  componentDidMount() {\n    this.setStateFromProps();\n  }\n\n  componentDidUpdate(prevProps) {\n    const { studies, displaySet } = this.props.viewportData;\n    const prevDisplaySet = prevProps.viewportData.displaySet;\n\n    if (\n      displaySet.displaySetInstanceUid !==\n        prevDisplaySet.displaySetInstanceUid ||\n      displaySet.sopInstanceUid !== prevDisplaySet.sopInstanceUid ||\n      displaySet.frameIndex !== prevDisplaySet.frameIndex\n    ) {\n      this.setStateFromProps();\n    }\n  }\n\n  render() {\n    let childrenWithProps = null;\n\n    if (!this.state.viewportData) {\n      return null;\n    }\n    const { viewportIndex } = this.props;\n    const {\n      imageIds,\n      currentImageIdIndex,\n      // If this comes from the instance, would be a better default\n      // `FrameTime` in the instance\n      // frameRate = 0,\n    } = this.state.viewportData.stack;\n\n    // TODO: Does it make more sense to use Context?\n    if (this.props.children && this.props.children.length) {\n      childrenWithProps = this.props.children.map((child, index) => {\n        return (\n          child &&\n          React.cloneElement(child, {\n            viewportIndex: this.props.viewportIndex,\n            key: index,\n          })\n        );\n      });\n    }\n\n    return (\n      <>\n        <ConnectedCornerstoneViewport\n          viewportIndex={viewportIndex}\n          imageIds={imageIds}\n          imageIdIndex={currentImageIdIndex}\n          // ~~ Connected (From REDUX)\n          // frameRate={frameRate}\n          // isPlaying={false}\n          // isStackPrefetchEnabled={true}\n          // onElementEnabled={() => {}}\n          // setViewportActive{() => {}}\n          {...this.props.customProps}\n        />\n        {childrenWithProps}\n      </>\n    );\n  }\n}\n\nexport default OHIFCornerstoneViewport;\n"],"sourceRoot":""}