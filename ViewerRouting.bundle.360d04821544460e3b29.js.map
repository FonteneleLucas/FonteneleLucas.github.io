{"version":3,"sources":["webpack:///./routes/ViewerRouting.js","webpack:///./customHooks/usePrevious.js","webpack:///./googleCloud/api/GoogleCloudApi.js","webpack:///./connectedComponents/ViewerRetrieveStudyData.js","webpack:///./connectedComponents/ConnectedViewerRetrieveStudyData.js","webpack:///./googleCloud/utils/getServers.js","webpack:///./customHooks/useServer.js"],"names":["UrlUtil","OHIF","utils","urlUtil","getSeriesInstanceUIDs","seriesInstanceUids","routeLocation","queryFilters","queryString","getQueryFilters","querySeriesUIDs","_seriesInstanceUids","paramString","parseParam","ViewerRouting","routeMatch","match","location","params","project","dataset","dicomStore","studyInstanceUids","server","useServer","studyUids","seriesUids","propTypes","PropTypes","shape","string","isRequired","usePrevious","value","ref","useRef","useEffect","current","GoogleCloudApi","accessToken","console","error","this","urlBase","urlStr","config","url","URL","data","search","URLSearchParams","fetch","fetchConfig","response","json","status","nextPageToken","pageToken","doRequest","key","subPage","hasOwnProperty","concat","isError","message","projectId","urlBaseProject","locationId","Error","method","headers","Authorization","healthcareApiEndpoint","OHIFStudyMetadata","metadata","OHIFSeriesMetadata","retrieveStudiesMetadata","studies","deleteStudyMetadataPromise","studyMetadataManager","updateMetaDataManager","makeCancelable","_promoteList","study","studyMetadata","filters","isFilterStrategy","promoted","_sortStudyDisplaySet","_promoteStudyDisplaySet","Object","keys","length","seriesInstanceUID","promotedResponse","list","searchMethod","index","findIndex","bind","undefined","first","splice","_promoteToFront","getDisplaySets","valueToCompare","displaySet","seriesInstanceUid","displaySets","_isQueryParamApplied","applied","seriesList","firstSeries","_showUserMessage","queryParamApplied","dialog","show","showUserMessage","_addSeriesToStudy","series","sopClassHandlerModules","extensionManager","modules","getData","seriesMetadata","addSeries","createAndAddDisplaySetsForSeries","_updateMetaDataManager","studyInstanceUid","get","add","_updateStudyDisplaySets","createDisplaySets","setDisplaySets","sortDisplaySets","_loadRemainingSeries","seriesLoader","Promise","resolve","promisesLoaders","hasNext","push","next","then","log","all","ViewerRetrieveStudyData","cancelableSeriesPromises","cancelableStudiesPromises","clearViewportSpecificData","useState","setError","setStudies","isStudyLoaded","setIsStudyLoaded","snackbarContext","useSnackbarContext","useContext","AppContext","appConfig","filterQueryParam","processStudies","studiesData","Array","isArray","map","result","isCanceled","isQueryParamApplied","studyDidLoad","catch","loadStudies","retrieveParams","purgeCancellablePromises","cancel","remove","prevStudyInstanceUids","every","e","includes","purge","JSON","stringify","ConnectedViewer","array","object","func","redux","actions","isActive","a","active","ConnectedViewerRetrieveStudyData","connect","state","ownProps","activeServer","servers","find","dispatch","getServers","name","wadoUriRoot","qidoRoot","wadoRoot","imageRendering","thumbnailRendering","type","supportsFuzzyMatching","qidoSupportsIncludeField","isValidServer","isEqualServer","toCompare","serverLength","toCompareLength","getActiveServer","enableGoogleCloudAdapter","pathUrl","getUrlBaseDicomWeb","GoogleCloudUtilServers","setServers","useServerFromUrl","previousServers","urlBasedServers","serverHasChanged","newServer","exists","some","useSelector","useDispatch"],"mappings":"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","file":"ViewerRouting.bundle.360d04821544460e3b29.js","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport ConnectedViewerRetrieveStudyData from '../connectedComponents/ConnectedViewerRetrieveStudyData';\nimport useServer from '../customHooks/useServer';\nimport OHIF from '@ohif/core';\nconst { urlUtil: UrlUtil } = OHIF.utils;\n\n/**\n * Get array of seriesUIDs from param or from queryString\n * @param {*} seriesInstanceUids\n * @param {*} location\n */\nconst getSeriesInstanceUIDs = (seriesInstanceUids, routeLocation) => {\n  const queryFilters = UrlUtil.queryString.getQueryFilters(routeLocation);\n  const querySeriesUIDs = queryFilters && queryFilters['seriesInstanceUID'];\n  const _seriesInstanceUids = seriesInstanceUids || querySeriesUIDs;\n\n  return UrlUtil.paramString.parseParam(_seriesInstanceUids);\n};\n\nfunction ViewerRouting({ match: routeMatch, location: routeLocation }) {\n  const {\n    project,\n    location,\n    dataset,\n    dicomStore,\n    studyInstanceUids,\n    seriesInstanceUids,\n  } = routeMatch.params;\n  const server = useServer({ project, location, dataset, dicomStore });\n\n  const studyUids = UrlUtil.paramString.parseParam(studyInstanceUids);\n  const seriesUids = getSeriesInstanceUIDs(seriesInstanceUids, routeLocation);\n\n  if (server && studyUids) {\n    return (\n      <ConnectedViewerRetrieveStudyData\n        studyInstanceUids={studyUids}\n        seriesInstanceUids={seriesUids}\n      />\n    );\n  }\n\n  return null;\n}\n\nViewerRouting.propTypes = {\n  match: PropTypes.shape({\n    params: PropTypes.shape({\n      studyInstanceUids: PropTypes.string.isRequired,\n      seriesInstanceUids: PropTypes.string,\n      dataset: PropTypes.string,\n      dicomStore: PropTypes.string,\n      location: PropTypes.string,\n      project: PropTypes.string,\n    }),\n  }),\n};\n\nexport default ViewerRouting;\n","import React, { useEffect, useRef } from 'react';\nexport default function usePrevious(value) {\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref.current;\n}\n","class GoogleCloudApi {\n  setAccessToken(accessToken) {\n    if (!accessToken) console.error('Access token is empty');\n    this.accessToken = accessToken;\n  }\n\n  get fetchConfig() {\n    if (!this.accessToken) throw new Error('OIDC access_token is not set');\n    return {\n      method: 'GET',\n      headers: {\n        Authorization: 'Bearer ' + this.accessToken,\n      },\n    };\n  }\n\n  get urlBase() {\n    return this.healthcareApiEndpoint || 'https://healthcare.googleapis.com/v1beta1';\n  }\n\n  set urlBase(url) {\n    this.healthcareApiEndpoint = url;\n  }\n\n  get urlBaseProject() {\n    return this.urlBase + `/projects`;\n  }\n\n  getUrlBaseDicomWeb(project, location, dataset, dicomStore) {\n    return (\n      this.urlBase +\n      `/projects/${project}/locations/${location}/datasets/${dataset}/dicomStores/${dicomStore}/dicomWeb`\n    );\n  }\n\n  getUrlPath(project, location, dataset, dicomStore) {\n    `/projects/${project}/locations/${location}/datasets/${dataset}/dicomStores/${dicomStore}`;\n  }\n\n  async doRequest(urlStr, config = {}, params = {}) {\n    const url = new URL(urlStr);\n    let data = null;\n    url.search = new URLSearchParams(params);\n\n    try {\n      const response = await fetch(url, { ...this.fetchConfig, config });\n      try {\n        data = await response.json();\n      } catch (err) {}\n      if (response.status >= 200 && response.status < 300 && data != null) {\n        if (data.nextPageToken != null) {\n          params.pageToken = data.nextPageToken;\n          let subPage = await this.doRequest(urlStr, config, params);\n          for (let key in data) {\n            if (data.hasOwnProperty(key)) {\n              data[key] = data[key].concat(subPage.data[key]);\n            }\n          }\n        }\n        return {\n          isError: false,\n          status: response.status,\n          data,\n        };\n      } else {\n        return {\n          isError: true,\n          status: response.status,\n          message:\n            (data && data.error && data.error.message) || 'Unknown error',\n        };\n      }\n    } catch (err) {\n      if (data && data.error) {\n        return {\n          isError: true,\n          status: err.status,\n          message: err.response.data.error.message || 'Unspecified error',\n        };\n      }\n      return {\n        isError: true,\n        message: (err && err.message) || 'Oops! Something went wrong',\n      };\n    }\n  }\n\n  async loadProjects() {\n    return this.doRequest(\n      'https://cloudresourcemanager.googleapis.com/v1/projects'\n    );\n  }\n\n  async loadLocations(projectId) {\n    return this.doRequest(`${this.urlBaseProject}/${projectId}/locations`);\n  }\n\n  async loadDatasets(projectId, locationId) {\n    return this.doRequest(\n      `${this.urlBaseProject}/${projectId}/locations/${locationId}/datasets`\n    );\n  }\n\n  async loadDicomStores(dataset) {\n    return this.doRequest(`${this.urlBase}/${dataset}/dicomStores`);\n  }\n}\n\nexport default new GoogleCloudApi();\n","import React, { useState, useEffect, useContext } from 'react';\nimport { metadata, studies, utils, log } from '@ohif/core';\nimport usePrevious from '../customHooks/usePrevious';\n\nimport ConnectedViewer from './ConnectedViewer.js';\nimport PropTypes from 'prop-types';\nimport { extensionManager } from './../App.js';\nimport { useSnackbarContext } from '@ohif/ui';\n\nconst { OHIFStudyMetadata, OHIFSeriesMetadata } = metadata;\nconst { retrieveStudiesMetadata, deleteStudyMetadataPromise } = studies;\nconst { studyMetadataManager, updateMetaDataManager, makeCancelable } = utils;\n\n// Contexts\nimport AppContext from '../context/AppContext';\n\nconst _promoteToFront = (list, value, searchMethod) => {\n  let response = [...list];\n  let promoted = false;\n  const index = response.findIndex(searchMethod.bind(undefined, value));\n\n  if (index > 0) {\n    const first = response.splice(index, 1);\n    response = [...first, ...response];\n  }\n\n  if (index >= 0) {\n    promoted = true;\n  }\n\n  return {\n    promoted,\n    data: response,\n  };\n};\n\n/**\n * Promote series to front if find found equivalent on filters object\n * @param {Object} study - study reference to promote series against\n * @param {Object} [filters] - Object containing filters to be applied\n * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\n * @param {boolean} isFilterStrategy - if filtering by query param strategy ON\n */\nconst _promoteList = (study, studyMetadata, filters, isFilterStrategy) => {\n  let promoted = false;\n  // Promote only if no filter should be applied\n  if (!isFilterStrategy) {\n    _sortStudyDisplaySet(study, studyMetadata);\n    promoted = _promoteStudyDisplaySet(study, studyMetadata, filters);\n  }\n\n  return promoted;\n};\n\nconst _promoteStudyDisplaySet = (study, studyMetadata, filters) => {\n  let promoted = false;\n  const queryParamsLength = Object.keys(filters).length;\n  const shouldPromoteToFront = queryParamsLength > 0;\n\n  if (shouldPromoteToFront) {\n    const { seriesInstanceUID } = filters;\n\n    const _seriesLookup = (valueToCompare, displaySet) => {\n      return displaySet.seriesInstanceUid === valueToCompare;\n    };\n    const promotedResponse = _promoteToFront(\n      studyMetadata.getDisplaySets(),\n      seriesInstanceUID,\n      _seriesLookup\n    );\n\n    study.displaySets = promotedResponse.data;\n    promoted = promotedResponse.promoted;\n  }\n\n  return promoted;\n};\n\n/**\n * Method to identify if query param (from url) was applied to given list\n * @param {Object} study - study reference to promote series against\n * @param {Object} [filters] - Object containing filters to be applied\n * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\n * @param {boolean} isFilterStrategy - if filtering by query param strategy ON\n */\nconst _isQueryParamApplied = (study, filters = {}, isFilterStrategy) => {\n  const { seriesInstanceUID } = filters;\n  let applied = true;\n  // skip in case no filter or no toast manager\n  if (!seriesInstanceUID) {\n    return applied;\n  }\n\n  const { seriesList = [], displaySets = [] } = study;\n  const firstSeries = isFilterStrategy ? seriesList[0] : displaySets[0];\n\n  if (!firstSeries || firstSeries.seriesInstanceUid !== seriesInstanceUID) {\n    applied = false;\n  }\n\n  return applied;\n};\nconst _showUserMessage = (queryParamApplied, message, dialog = {}) => {\n  if (queryParamApplied) {\n    return;\n  }\n\n  const { show: showUserMessage = () => { } } = dialog;\n  showUserMessage({\n    message,\n  });\n};\n\nconst _addSeriesToStudy = (studyMetadata, series) => {\n  const sopClassHandlerModules =\n    extensionManager.modules['sopClassHandlerModule'];\n  const study = studyMetadata.getData();\n  const seriesMetadata = new OHIFSeriesMetadata(series, study);\n  studyMetadata.addSeries(seriesMetadata);\n  studyMetadata.createAndAddDisplaySetsForSeries(\n    sopClassHandlerModules,\n    seriesMetadata,\n    false\n  );\n  study.displaySets = studyMetadata.getDisplaySets();\n  _updateMetaDataManager(study, series.seriesInstanceUid);\n};\n\nconst _updateMetaDataManager = (study, studyMetadata, series) => {\n  updateMetaDataManager(study, series);\n\n  const { studyInstanceUid } = study;\n\n  if (!studyMetadataManager.get(studyInstanceUid)) {\n    studyMetadataManager.add(studyMetadata);\n  }\n};\n\nconst _updateStudyDisplaySets = (study, studyMetadata) => {\n  const sopClassHandlerModules =\n    extensionManager.modules['sopClassHandlerModule'];\n\n  if (!study.displaySets) {\n    study.displaySets = studyMetadata.createDisplaySets(sopClassHandlerModules);\n  }\n\n  studyMetadata.setDisplaySets(study.displaySets);\n};\n\nconst _sortStudyDisplaySet = (study, studyMetadata) => {\n  studyMetadata.sortDisplaySets(study.displaySets);\n};\nconst _loadRemainingSeries = studyMetadata => {\n  const { seriesLoader } = studyMetadata.getData();\n  if (!seriesLoader) {\n    return Promise.resolve();\n  }\n  const promisesLoaders = [];\n  while (seriesLoader.hasNext()) {\n    promisesLoaders.push(\n      seriesLoader\n        .next()\n        .then(\n          series => void _addSeriesToStudy(studyMetadata, series),\n          error => void log.error(error)\n        )\n    );\n  }\n\n  return Promise.all(promisesLoaders);\n};\n\nfunction ViewerRetrieveStudyData({\n  server,\n  studyInstanceUids,\n  seriesInstanceUids,\n  clearViewportSpecificData,\n}) {\n  // hooks\n  const [error, setError] = useState(false);\n  const [studies, setStudies] = useState([]);\n  const [isStudyLoaded, setIsStudyLoaded] = useState(false);\n  const snackbarContext = useSnackbarContext();\n  const { appConfig = {} } = useContext(AppContext);\n  const { filterQueryParam: isFilterStrategy = false } = appConfig;\n\n  let cancelableSeriesPromises;\n  let cancelableStudiesPromises;\n  /**\n   * Callback method when study is totally loaded\n   * @param {object} study study loaded\n   * @param {object} studyMetadata studyMetadata for given study\n   * @param {Object} [filters] - Object containing filters to be applied\n   * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\n   */\n  const studyDidLoad = (study, studyMetadata, filters) => {\n    // User message\n    const promoted = _promoteList(\n      study,\n      studyMetadata,\n      filters,\n      isFilterStrategy\n    );\n\n    // Clear viewport to allow new promoted one to be displayed\n    if (promoted) {\n      clearViewportSpecificData(0);\n    }\n\n    const isQueryParamApplied = _isQueryParamApplied(\n      study,\n      filters,\n      isFilterStrategy\n    );\n    // Show message in case not promoted neither filtered but should to\n    _showUserMessage(\n      isQueryParamApplied,\n      'Query parameters were not applied. Using original series list for given study.',\n      snackbarContext\n    );\n\n    setStudies([...studies, study]);\n    setIsStudyLoaded(true);\n  };\n\n  /**\n   * Method to process studies. It will update displaySet, studyMetadata, load remaining series, ...\n   * @param {Array} studiesData Array of studies retrieved from server\n   * @param {Object} [filters] - Object containing filters to be applied\n   * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\n   */\n  const processStudies = (studiesData, filters) => {\n    if (Array.isArray(studiesData) && studiesData.length > 0) {\n      // Map studies to new format, update metadata manager?\n      const studies = studiesData.map(study => {\n        const studyMetadata = new OHIFStudyMetadata(\n          study,\n          study.studyInstanceUid\n        );\n\n        _updateStudyDisplaySets(study, studyMetadata);\n        _updateMetaDataManager(study, studyMetadata);\n\n        // Attempt to load remaning series if any\n        cancelableSeriesPromises[study.studyInstanceUid] = makeCancelable(\n          _loadRemainingSeries(studyMetadata)\n        )\n          .then(result => {\n            if (result && !result.isCanceled) {\n              studyDidLoad(study, studyMetadata, filters);\n            }\n          })\n          .catch(error => {\n            if (error && !error.isCanceled) {\n              setError(true);\n              log.error(error);\n            }\n          });\n\n        return study;\n      });\n\n      setStudies(studies);\n    }\n  };\n\n  const loadStudies = async () => {\n    try {\n      const filters = {};\n      // Use the first, discard others\n      const seriesInstanceUID = seriesInstanceUids && seriesInstanceUids[0];\n\n      const retrieveParams = [server, studyInstanceUids];\n\n      if (seriesInstanceUID) {\n        filters.seriesInstanceUID = seriesInstanceUID;\n        // Query param filtering controlled by appConfig property\n        if (isFilterStrategy) {\n          retrieveParams.push(filters);\n        }\n      }\n\n      cancelableStudiesPromises[studyInstanceUids] = makeCancelable(\n        retrieveStudiesMetadata(...retrieveParams)\n      )\n        .then(result => {\n          if (result && !result.isCanceled) {\n            processStudies(result, filters);\n          }\n        })\n        .catch(error => {\n          if (error && !error.isCanceled) {\n            setError(true);\n            log.error(error);\n          }\n        });\n    } catch (error) {\n      if (error) {\n        setError(true);\n        log.error(error);\n      }\n    }\n  };\n\n  const purgeCancellablePromises = () => {\n    for (let studyInstanceUids in cancelableStudiesPromises) {\n      if ('cancel' in cancelableStudiesPromises[studyInstanceUids]) {\n        cancelableStudiesPromises[studyInstanceUids].cancel();\n      }\n    }\n\n    for (let studyInstanceUids in cancelableSeriesPromises) {\n      if ('cancel' in cancelableSeriesPromises[studyInstanceUids]) {\n        cancelableSeriesPromises[studyInstanceUids].cancel();\n        deleteStudyMetadataPromise(studyInstanceUids);\n        studyMetadataManager.remove(studyInstanceUids);\n      }\n    }\n  };\n\n  const prevStudyInstanceUids = usePrevious(studyInstanceUids);\n\n  useEffect(() => {\n    const hasStudyInstanceUidsChanged = !(prevStudyInstanceUids && prevStudyInstanceUids.every(e => studyInstanceUids.includes(e)));\n\n    if (hasStudyInstanceUidsChanged) {\n      studyMetadataManager.purge();\n      purgeCancellablePromises();\n    }\n  }, [studyInstanceUids]);\n\n  useEffect(() => {\n    cancelableSeriesPromises = {};\n    cancelableStudiesPromises = {};\n    loadStudies();\n\n    return () => {\n      purgeCancellablePromises();\n    };\n  }, []);\n\n  if (error) {\n    return <div>Error: {JSON.stringify(error)}</div>;\n  }\n\n  return (\n    <ConnectedViewer\n      studies={studies}\n      isStudyLoaded={isStudyLoaded}\n      studyInstanceUids={studyInstanceUids}\n    />\n  );\n}\n\nViewerRetrieveStudyData.propTypes = {\n  studyInstanceUids: PropTypes.array.isRequired,\n  seriesInstanceUids: PropTypes.array,\n  server: PropTypes.object,\n  clearViewportSpecificData: PropTypes.func.isRequired,\n};\n\nexport default ViewerRetrieveStudyData;\n","import { connect } from 'react-redux';\nimport ViewerRetrieveStudyData from './ViewerRetrieveStudyData.js';\nimport OHIF from \"@ohif/core\";\n\nconst { clearViewportSpecificData } = OHIF.redux.actions;\nconst isActive = a => a.active === true;\n\nconst mapStateToProps = (state, ownProps) => {\n  const activeServer = state.servers.servers.find(isActive);\n\n  return {\n    server: ownProps.server || activeServer,\n  };\n};\nconst mapDispatchToProps = dispatch => {\n  return {\n    clearViewportSpecificData: () => {\n      dispatch(clearViewportSpecificData());\n    },\n  };\n};\n\nconst ConnectedViewerRetrieveStudyData = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(ViewerRetrieveStudyData);\n\nexport default ConnectedViewerRetrieveStudyData;\n","const getServers = (data, name) => {\n  const {\n    wadoUriRoot,\n    qidoRoot,\n    wadoRoot,\n    dataset = '',\n    dicomStore = '',\n    location = '',\n    project = '',\n  } = data;\n\n  return [\n    {\n      name: name,\n      dataset,\n      dicomStore,\n      location,\n      project,\n      imageRendering: 'wadors',\n      thumbnailRendering: 'wadors',\n      type: 'dicomWeb',\n      active: true,\n      wadoUriRoot,\n      qidoRoot,\n      wadoRoot,\n      supportsFuzzyMatching: false,\n      qidoSupportsIncludeField: false,\n    },\n  ];\n};\n\nconst isValidServer = server => {\n  return (\n    server &&\n    !!server.dataset &&\n    !!server.dicomStore &&\n    !!server.location &&\n    !!server.project\n  );\n};\n\nconst isEqualServer = (server = {}, toCompare = {}) => {\n  const serverLength = Object.keys(server).length;\n  const toCompareLength = Object.keys(toCompare).length;\n\n  if (!serverLength || !toCompareLength) {\n    return false;\n  }\n\n  return (\n    server.dataset === toCompare.dataset &&\n    server.dataset === toCompare.dataset &&\n    server.dicomStore === toCompare.dicomStore &&\n    server.location === toCompare.location &&\n    server.project === toCompare.project\n  );\n};\n\nexport { getServers, isValidServer, isEqualServer };\n","import React, { useContext } from 'react';\nimport GoogleCloudApi from '../googleCloud/api/GoogleCloudApi';\nimport usePrevious from './usePrevious';\n\nimport * as GoogleCloudUtilServers from '../googleCloud/utils/getServers';\nimport { useSelector, useDispatch } from 'react-redux';\nimport isEqual from 'lodash.isequal';\n\n// Contexts\nimport AppContext from '../context/AppContext';\n\nconst getActiveServer = servers => {\n  const isActive = a => a.active === true;\n\n  return servers && servers.servers && servers.servers.find(isActive);\n};\n\nconst getServers = (appConfig, project, location, dataset, dicomStore) => {\n  let servers = [];\n  if (appConfig.enableGoogleCloudAdapter) {\n    GoogleCloudApi.urlBase = appConfig.healthcareApiEndpoint;\n    const pathUrl = GoogleCloudApi.getUrlBaseDicomWeb(\n      project,\n      location,\n      dataset,\n      dicomStore\n    );\n    const data = {\n      project,\n      location,\n      dataset,\n      dicomStore,\n      wadoUriRoot: pathUrl,\n      qidoRoot: pathUrl,\n      wadoRoot: pathUrl,\n    };\n    servers = GoogleCloudUtilServers.getServers(data, dicomStore);\n    if (!isValidServer(servers[0], appConfig)) {\n      return;\n    }\n  }\n\n  return servers;\n};\n\nconst isValidServer = (server, appConfig) => {\n  if (appConfig.enableGoogleCloudAdapter) {\n    return GoogleCloudUtilServers.isValidServer(server);\n  }\n\n  return !!server;\n};\n\nconst setServers = (dispatch, servers) => {\n  const action = {\n    type: 'SET_SERVERS',\n    servers,\n  };\n  dispatch(action);\n};\n\nconst useServerFromUrl = (\n  servers = [],\n  previousServers,\n  activeServer,\n  urlBasedServers,\n  appConfig,\n  project,\n  location,\n  dataset,\n  dicomStore\n) => {\n  // update state from url available only when gcloud on\n  if (!appConfig.enableGoogleCloudAdapter) {\n    return false;\n  }\n\n  const serverHasChanged = previousServers !== servers && previousServers;\n\n  // do not update from url. use state instead.\n  if (serverHasChanged) {\n    return false;\n  }\n\n  // if no valid urlbased servers\n  if (!urlBasedServers || !urlBasedServers.length) {\n    return false;\n  } else if (!servers.length || !activeServer) {\n    // no current valid server\n    return true;\n  }\n\n  const newServer = urlBasedServers[0];\n\n  let exists = servers.some(\n    GoogleCloudUtilServers.isEqualServer.bind(undefined, newServer)\n  );\n\n  return !exists;\n};\n\nexport default function useServer({\n  project,\n  location,\n  dataset,\n  dicomStore,\n} = {}) {\n  // Hooks\n  const servers = useSelector(state => state && state.servers);\n  const previousServers = usePrevious(servers);\n  const dispatch = useDispatch();\n\n  const { appConfig = {} } = useContext(AppContext);\n\n  const activeServer = getActiveServer(servers);\n  const urlBasedServers =\n    getServers(appConfig, project, location, dataset, dicomStore) || [];\n  const shouldUpdateServer = useServerFromUrl(\n    servers.servers,\n    previousServers,\n    activeServer,\n    urlBasedServers,\n    appConfig,\n    project,\n    location,\n    dataset,\n    dicomStore\n  );\n\n  if (shouldUpdateServer) {\n    setServers(dispatch, urlBasedServers);\n  } else if (isValidServer(activeServer, appConfig)) {\n    return activeServer;\n  }\n}\n"],"sourceRoot":""}