{"version":3,"sources":["webpack:///./routes/IHEInvokeImageDisplay.js","webpack:///./customHooks/usePrevious.js","webpack:///./connectedComponents/ViewerRetrieveStudyData.js","webpack:///./connectedComponents/ConnectedViewerRetrieveStudyData.js"],"names":["UrlUtil","OHIF","utils","urlUtil","IHEInvokeImageDisplay","location","parse","search","requestType","studyUID","studyInstanceUids","split","paramString","parseParam","propTypes","PropTypes","shape","string","isRequired","withRouter","usePrevious","value","ref","useRef","useEffect","current","OHIFStudyMetadata","metadata","OHIFSeriesMetadata","retrieveStudiesMetadata","studies","deleteStudyMetadataPromise","studyMetadataManager","updateMetaDataManager","makeCancelable","_promoteList","study","studyMetadata","filters","isFilterStrategy","promoted","_sortStudyDisplaySet","_promoteStudyDisplaySet","Object","keys","length","seriesInstanceUID","promotedResponse","list","searchMethod","response","index","findIndex","bind","undefined","first","splice","data","_promoteToFront","getDisplaySets","valueToCompare","displaySet","seriesInstanceUid","displaySets","_isQueryParamApplied","applied","seriesList","firstSeries","_showUserMessage","queryParamApplied","message","dialog","show","showUserMessage","_addSeriesToStudy","series","sopClassHandlerModules","extensionManager","modules","getData","seriesMetadata","addSeries","createAndAddDisplaySetsForSeries","_updateMetaDataManager","studyInstanceUid","get","add","_updateStudyDisplaySets","createDisplaySets","setDisplaySets","sortDisplaySets","_loadRemainingSeries","seriesLoader","Promise","resolve","promisesLoaders","hasNext","push","next","then","error","log","all","ViewerRetrieveStudyData","cancelableSeriesPromises","cancelableStudiesPromises","server","seriesInstanceUids","clearViewportSpecificData","useState","setError","setStudies","isStudyLoaded","setIsStudyLoaded","snackbarContext","useSnackbarContext","useContext","AppContext","appConfig","filterQueryParam","processStudies","studiesData","Array","isArray","map","result","isCanceled","isQueryParamApplied","studyDidLoad","catch","loadStudies","retrieveParams","purgeCancellablePromises","cancel","remove","prevStudyInstanceUids","every","e","includes","purge","JSON","stringify","ConnectedViewer","array","object","func","redux","actions","isActive","a","active","ConnectedViewerRetrieveStudyData","connect","state","ownProps","activeServer","servers","find","dispatch"],"mappings":"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","file":"IHEInvokeImageDisplay.bundle.58ff83f440c7aa887002.js","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport { withRouter } from 'react-router-dom';\nimport ConnectedViewerRetrieveStudyData from '../connectedComponents/ConnectedViewerRetrieveStudyData.js';\nimport OHIF from '@ohif/core';\nconst { urlUtil: UrlUtil } = OHIF.utils;\n\nfunction IHEInvokeImageDisplay({ location }) {\n  const {\n    // patientID,\n    requestType,\n    studyUID,\n  } = UrlUtil.parse(location.search);\n\n  switch (requestType) {\n    case 'STUDY':\n      return (\n        <ConnectedViewerRetrieveStudyData\n          studyInstanceUids={studyUID.split(';')}\n        />\n      );\n\n    case 'STUDYBASE64':\n      return (\n        <ConnectedViewerRetrieveStudyData\n          studyInstanceUids={UrlUtil.paramString.parseParam(studyUID)}\n        />\n      );\n\n    case 'PATIENT':\n      // TODO: connect this to the StudyList when we have the filter parameters set up\n      // return <StudyList patientUids={patientID.split(';')} />;\n      return '';\n\n    default:\n      // TODO: Figure out what to do here, this won't work because StudyList expects studies\n      // return <StudyList />;\n      return '';\n  }\n}\n\nIHEInvokeImageDisplay.propTypes = {\n  location: PropTypes.shape({\n    search: PropTypes.string,\n  }).isRequired,\n};\n\nexport default withRouter(IHEInvokeImageDisplay);\n","import React, { useEffect, useRef } from 'react';\nexport default function usePrevious(value) {\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref.current;\n}\n","import React, { useState, useEffect, useContext } from 'react';\nimport { metadata, studies, utils, log } from '@ohif/core';\nimport usePrevious from '../customHooks/usePrevious';\n\nimport ConnectedViewer from './ConnectedViewer.js';\nimport PropTypes from 'prop-types';\nimport { extensionManager } from './../App.js';\nimport { useSnackbarContext } from '@ohif/ui';\n\nconst { OHIFStudyMetadata, OHIFSeriesMetadata } = metadata;\nconst { retrieveStudiesMetadata, deleteStudyMetadataPromise } = studies;\nconst { studyMetadataManager, updateMetaDataManager, makeCancelable } = utils;\n\n// Contexts\nimport AppContext from '../context/AppContext';\n\nconst _promoteToFront = (list, value, searchMethod) => {\n  let response = [...list];\n  let promoted = false;\n  const index = response.findIndex(searchMethod.bind(undefined, value));\n\n  if (index > 0) {\n    const first = response.splice(index, 1);\n    response = [...first, ...response];\n  }\n\n  if (index >= 0) {\n    promoted = true;\n  }\n\n  return {\n    promoted,\n    data: response,\n  };\n};\n\n/**\n * Promote series to front if find found equivalent on filters object\n * @param {Object} study - study reference to promote series against\n * @param {Object} [filters] - Object containing filters to be applied\n * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\n * @param {boolean} isFilterStrategy - if filtering by query param strategy ON\n */\nconst _promoteList = (study, studyMetadata, filters, isFilterStrategy) => {\n  let promoted = false;\n  // Promote only if no filter should be applied\n  if (!isFilterStrategy) {\n    _sortStudyDisplaySet(study, studyMetadata);\n    promoted = _promoteStudyDisplaySet(study, studyMetadata, filters);\n  }\n\n  return promoted;\n};\n\nconst _promoteStudyDisplaySet = (study, studyMetadata, filters) => {\n  let promoted = false;\n  const queryParamsLength = Object.keys(filters).length;\n  const shouldPromoteToFront = queryParamsLength > 0;\n\n  if (shouldPromoteToFront) {\n    const { seriesInstanceUID } = filters;\n\n    const _seriesLookup = (valueToCompare, displaySet) => {\n      return displaySet.seriesInstanceUid === valueToCompare;\n    };\n    const promotedResponse = _promoteToFront(\n      studyMetadata.getDisplaySets(),\n      seriesInstanceUID,\n      _seriesLookup\n    );\n\n    study.displaySets = promotedResponse.data;\n    promoted = promotedResponse.promoted;\n  }\n\n  return promoted;\n};\n\n/**\n * Method to identify if query param (from url) was applied to given list\n * @param {Object} study - study reference to promote series against\n * @param {Object} [filters] - Object containing filters to be applied\n * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\n * @param {boolean} isFilterStrategy - if filtering by query param strategy ON\n */\nconst _isQueryParamApplied = (study, filters = {}, isFilterStrategy) => {\n  const { seriesInstanceUID } = filters;\n  let applied = true;\n  // skip in case no filter or no toast manager\n  if (!seriesInstanceUID) {\n    return applied;\n  }\n\n  const { seriesList = [], displaySets = [] } = study;\n  const firstSeries = isFilterStrategy ? seriesList[0] : displaySets[0];\n\n  if (!firstSeries || firstSeries.seriesInstanceUid !== seriesInstanceUID) {\n    applied = false;\n  }\n\n  return applied;\n};\nconst _showUserMessage = (queryParamApplied, message, dialog = {}) => {\n  if (queryParamApplied) {\n    return;\n  }\n\n  const { show: showUserMessage = () => { } } = dialog;\n  showUserMessage({\n    message,\n  });\n};\n\nconst _addSeriesToStudy = (studyMetadata, series) => {\n  const sopClassHandlerModules =\n    extensionManager.modules['sopClassHandlerModule'];\n  const study = studyMetadata.getData();\n  const seriesMetadata = new OHIFSeriesMetadata(series, study);\n  studyMetadata.addSeries(seriesMetadata);\n  studyMetadata.createAndAddDisplaySetsForSeries(\n    sopClassHandlerModules,\n    seriesMetadata,\n    false\n  );\n  study.displaySets = studyMetadata.getDisplaySets();\n  _updateMetaDataManager(study, series.seriesInstanceUid);\n};\n\nconst _updateMetaDataManager = (study, studyMetadata, series) => {\n  updateMetaDataManager(study, series);\n\n  const { studyInstanceUid } = study;\n\n  if (!studyMetadataManager.get(studyInstanceUid)) {\n    studyMetadataManager.add(studyMetadata);\n  }\n};\n\nconst _updateStudyDisplaySets = (study, studyMetadata) => {\n  const sopClassHandlerModules =\n    extensionManager.modules['sopClassHandlerModule'];\n\n  if (!study.displaySets) {\n    study.displaySets = studyMetadata.createDisplaySets(sopClassHandlerModules);\n  }\n\n  studyMetadata.setDisplaySets(study.displaySets);\n};\n\nconst _sortStudyDisplaySet = (study, studyMetadata) => {\n  studyMetadata.sortDisplaySets(study.displaySets);\n};\nconst _loadRemainingSeries = studyMetadata => {\n  const { seriesLoader } = studyMetadata.getData();\n  if (!seriesLoader) {\n    return Promise.resolve();\n  }\n  const promisesLoaders = [];\n  while (seriesLoader.hasNext()) {\n    promisesLoaders.push(\n      seriesLoader\n        .next()\n        .then(\n          series => void _addSeriesToStudy(studyMetadata, series),\n          error => void log.error(error)\n        )\n    );\n  }\n\n  return Promise.all(promisesLoaders);\n};\n\nfunction ViewerRetrieveStudyData({\n  server,\n  studyInstanceUids,\n  seriesInstanceUids,\n  clearViewportSpecificData,\n}) {\n  // hooks\n  const [error, setError] = useState(false);\n  const [studies, setStudies] = useState([]);\n  const [isStudyLoaded, setIsStudyLoaded] = useState(false);\n  const snackbarContext = useSnackbarContext();\n  const { appConfig = {} } = useContext(AppContext);\n  const { filterQueryParam: isFilterStrategy = false } = appConfig;\n\n  let cancelableSeriesPromises;\n  let cancelableStudiesPromises;\n  /**\n   * Callback method when study is totally loaded\n   * @param {object} study study loaded\n   * @param {object} studyMetadata studyMetadata for given study\n   * @param {Object} [filters] - Object containing filters to be applied\n   * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\n   */\n  const studyDidLoad = (study, studyMetadata, filters) => {\n    // User message\n    const promoted = _promoteList(\n      study,\n      studyMetadata,\n      filters,\n      isFilterStrategy\n    );\n\n    // Clear viewport to allow new promoted one to be displayed\n    if (promoted) {\n      clearViewportSpecificData(0);\n    }\n\n    const isQueryParamApplied = _isQueryParamApplied(\n      study,\n      filters,\n      isFilterStrategy\n    );\n    // Show message in case not promoted neither filtered but should to\n    _showUserMessage(\n      isQueryParamApplied,\n      'Query parameters were not applied. Using original series list for given study.',\n      snackbarContext\n    );\n\n    setStudies([...studies, study]);\n    setIsStudyLoaded(true);\n  };\n\n  /**\n   * Method to process studies. It will update displaySet, studyMetadata, load remaining series, ...\n   * @param {Array} studiesData Array of studies retrieved from server\n   * @param {Object} [filters] - Object containing filters to be applied\n   * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\n   */\n  const processStudies = (studiesData, filters) => {\n    if (Array.isArray(studiesData) && studiesData.length > 0) {\n      // Map studies to new format, update metadata manager?\n      const studies = studiesData.map(study => {\n        const studyMetadata = new OHIFStudyMetadata(\n          study,\n          study.studyInstanceUid\n        );\n\n        _updateStudyDisplaySets(study, studyMetadata);\n        _updateMetaDataManager(study, studyMetadata);\n\n        // Attempt to load remaning series if any\n        cancelableSeriesPromises[study.studyInstanceUid] = makeCancelable(\n          _loadRemainingSeries(studyMetadata)\n        )\n          .then(result => {\n            if (result && !result.isCanceled) {\n              studyDidLoad(study, studyMetadata, filters);\n            }\n          })\n          .catch(error => {\n            if (error && !error.isCanceled) {\n              setError(true);\n              log.error(error);\n            }\n          });\n\n        return study;\n      });\n\n      setStudies(studies);\n    }\n  };\n\n  const loadStudies = async () => {\n    try {\n      const filters = {};\n      // Use the first, discard others\n      const seriesInstanceUID = seriesInstanceUids && seriesInstanceUids[0];\n\n      const retrieveParams = [server, studyInstanceUids];\n\n      if (seriesInstanceUID) {\n        filters.seriesInstanceUID = seriesInstanceUID;\n        // Query param filtering controlled by appConfig property\n        if (isFilterStrategy) {\n          retrieveParams.push(filters);\n        }\n      }\n\n      cancelableStudiesPromises[studyInstanceUids] = makeCancelable(\n        retrieveStudiesMetadata(...retrieveParams)\n      )\n        .then(result => {\n          if (result && !result.isCanceled) {\n            processStudies(result, filters);\n          }\n        })\n        .catch(error => {\n          if (error && !error.isCanceled) {\n            setError(true);\n            log.error(error);\n          }\n        });\n    } catch (error) {\n      if (error) {\n        setError(true);\n        log.error(error);\n      }\n    }\n  };\n\n  const purgeCancellablePromises = () => {\n    for (let studyInstanceUids in cancelableStudiesPromises) {\n      if ('cancel' in cancelableStudiesPromises[studyInstanceUids]) {\n        cancelableStudiesPromises[studyInstanceUids].cancel();\n      }\n    }\n\n    for (let studyInstanceUids in cancelableSeriesPromises) {\n      if ('cancel' in cancelableSeriesPromises[studyInstanceUids]) {\n        cancelableSeriesPromises[studyInstanceUids].cancel();\n        deleteStudyMetadataPromise(studyInstanceUids);\n        studyMetadataManager.remove(studyInstanceUids);\n      }\n    }\n  };\n\n  const prevStudyInstanceUids = usePrevious(studyInstanceUids);\n\n  useEffect(() => {\n    const hasStudyInstanceUidsChanged = !(prevStudyInstanceUids && prevStudyInstanceUids.every(e => studyInstanceUids.includes(e)));\n\n    if (hasStudyInstanceUidsChanged) {\n      studyMetadataManager.purge();\n      purgeCancellablePromises();\n    }\n  }, [studyInstanceUids]);\n\n  useEffect(() => {\n    cancelableSeriesPromises = {};\n    cancelableStudiesPromises = {};\n    loadStudies();\n\n    return () => {\n      purgeCancellablePromises();\n    };\n  }, []);\n\n  if (error) {\n    return <div>Error: {JSON.stringify(error)}</div>;\n  }\n\n  return (\n    <ConnectedViewer\n      studies={studies}\n      isStudyLoaded={isStudyLoaded}\n      studyInstanceUids={studyInstanceUids}\n    />\n  );\n}\n\nViewerRetrieveStudyData.propTypes = {\n  studyInstanceUids: PropTypes.array.isRequired,\n  seriesInstanceUids: PropTypes.array,\n  server: PropTypes.object,\n  clearViewportSpecificData: PropTypes.func.isRequired,\n};\n\nexport default ViewerRetrieveStudyData;\n","import { connect } from 'react-redux';\nimport ViewerRetrieveStudyData from './ViewerRetrieveStudyData.js';\nimport OHIF from \"@ohif/core\";\n\nconst { clearViewportSpecificData } = OHIF.redux.actions;\nconst isActive = a => a.active === true;\n\nconst mapStateToProps = (state, ownProps) => {\n  const activeServer = state.servers.servers.find(isActive);\n\n  return {\n    server: ownProps.server || activeServer,\n  };\n};\nconst mapDispatchToProps = dispatch => {\n  return {\n    clearViewportSpecificData: () => {\n      dispatch(clearViewportSpecificData());\n    },\n  };\n};\n\nconst ConnectedViewerRetrieveStudyData = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(ViewerRetrieveStudyData);\n\nexport default ConnectedViewerRetrieveStudyData;\n"],"sourceRoot":""}